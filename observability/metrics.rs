use prometheus::{
    Counter, Gauge, Histogram, IntCounter, IntGauge, 
    register_counter, register_gauge, register_histogram, register_int_counter, register_int_gauge,
    Opts, HistogramOpts, Registry, Encoder, TextEncoder
};\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse tracing::{info, warn, error};\nuse std::collections::HashMap;\n\n#[derive(Clone)]\npub struct MetricsCollector {\n    // Trading metrics\n    trades_total: IntCounter,\n    trades_successful: IntCounter,\n    trades_failed: IntCounter,\n    trade_volume_sol: Counter,\n    trade_duration: Histogram,\n    \n    // API metrics\n    jupiter_requests_total: IntCounter,\n    jupiter_requests_failed: IntCounter,\n    jupiter_response_time: Histogram,\n    \n    helius_requests_total: IntCounter,\n    helius_requests_failed: IntCounter,\n    helius_response_time: Histogram,\n    \n    solana_rpc_requests_total: IntCounter,\n    solana_rpc_requests_failed: IntCounter,\n    solana_rpc_response_time: Histogram,\n    \n    // Cache metrics\n    cache_hits_total: IntCounter,\n    cache_misses_total: IntCounter,\n    cache_entries: IntGauge,\n    cache_hit_rate: Gauge,\n    \n    // Circuit breaker metrics\n    circuit_breaker_state: IntGauge, // 0=closed, 1=half-open, 2=open\n    circuit_breaker_failures: IntCounter,\n    \n    // User metrics\n    active_users: IntGauge,\n    user_requests_total: IntCounter,\n    user_requests_rate_limited: IntCounter,\n    \n    // System metrics\n    memory_usage_bytes: IntGauge,\n    cpu_usage_percent: Gauge,\n    goroutines_count: IntGauge,\n    \n    // Business metrics\n    total_volume_traded_usd: Counter,\n    total_rebates_earned_sol: Counter,\n    unique_tokens_traded: IntGauge,\n    \n    // Custom registry for this application\n    registry: Registry,\n    \n    // Runtime stats\n    start_time: Instant,\n    last_metrics_export: Arc<RwLock<Instant>>,\n}\n\nimpl MetricsCollector {\n    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {\n        info!(\"Initializing comprehensive metrics collector\");\n        \n        let registry = Registry::new();\n        \n        // Trading metrics\n        let trades_total = register_int_counter!(\n            Opts::new(\"trades_total\", \"Total number of trades executed\")\n        )?;\n        let trades_successful = register_int_counter!(\n            Opts::new(\"trades_successful_total\", \"Total number of successful trades\")\n        )?;\n        let trades_failed = register_int_counter!(\n            Opts::new(\"trades_failed_total\", \"Total number of failed trades\")\n        )?;\n        let trade_volume_sol = register_counter!(\n            Opts::new(\"trade_volume_sol_total\", \"Total trading volume in SOL\")\n        )?;\n        let trade_duration = register_histogram!(\n            HistogramOpts::new(\"trade_duration_seconds\", \"Time taken to execute trades\")\n                .buckets(vec![0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0])\n        )?;\n        \n        // Jupiter API metrics\n        let jupiter_requests_total = register_int_counter!(\n            Opts::new(\"jupiter_requests_total\", \"Total requests to Jupiter API\")\n        )?;\n        let jupiter_requests_failed = register_int_counter!(\n            Opts::new(\"jupiter_requests_failed_total\", \"Failed requests to Jupiter API\")\n        )?;\n        let jupiter_response_time = register_histogram!(\n            HistogramOpts::new(\"jupiter_response_time_seconds\", \"Jupiter API response time\")\n                .buckets(vec![0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0])\n        )?;\n        \n        // Helius API metrics\n        let helius_requests_total = register_int_counter!(\n            Opts::new(\"helius_requests_total\", \"Total requests to Helius API\")\n        )?;\n        let helius_requests_failed = register_int_counter!(\n            Opts::new(\"helius_requests_failed_total\", \"Failed requests to Helius API\")\n        )?;\n        let helius_response_time = register_histogram!(\n            HistogramOpts::new(\"helius_response_time_seconds\", \"Helius API response time\")\n                .buckets(vec![0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0])\n        )?;\n        \n        // Solana RPC metrics\n        let solana_rpc_requests_total = register_int_counter!(\n            Opts::new(\"solana_rpc_requests_total\", \"Total requests to Solana RPC\")\n        )?;\n        let solana_rpc_requests_failed = register_int_counter!(\n            Opts::new(\"solana_rpc_requests_failed_total\", \"Failed requests to Solana RPC\")\n        )?;\n        let solana_rpc_response_time = register_histogram!(\n            HistogramOpts::new(\"solana_rpc_response_time_seconds\", \"Solana RPC response time\")\n                .buckets(vec![0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0])\n        )?;\n        \n        // Cache metrics\n        let cache_hits_total = register_int_counter!(\n            Opts::new(\"cache_hits_total\", \"Total cache hits across all layers\")\n        )?;\n        let cache_misses_total = register_int_counter!(\n            Opts::new(\"cache_misses_total\", \"Total cache misses across all layers\")\n        )?;\n        let cache_entries = register_int_gauge!(\n            Opts::new(\"cache_entries_current\", \"Current number of cache entries\")\n        )?;\n        let cache_hit_rate = register_gauge!(\n            Opts::new(\"cache_hit_rate_percent\", \"Cache hit rate percentage\")\n        )?;\n        \n        // Circuit breaker metrics\n        let circuit_breaker_state = register_int_gauge!(\n            Opts::new(\"circuit_breaker_state\", \"Circuit breaker state (0=closed, 1=half-open, 2=open)\")\n        )?;\n        let circuit_breaker_failures = register_int_counter!(\n            Opts::new(\"circuit_breaker_failures_total\", \"Total circuit breaker failures\")\n        )?;\n        \n        // User metrics\n        let active_users = register_int_gauge!(\n            Opts::new(\"active_users_current\", \"Current number of active users\")\n        )?;\n        let user_requests_total = register_int_counter!(\n            Opts::new(\"user_requests_total\", \"Total user requests\")\n        )?;\n        let user_requests_rate_limited = register_int_counter!(\n            Opts::new(\"user_requests_rate_limited_total\", \"Total rate limited user requests\")\n        )?;\n        \n        // System metrics\n        let memory_usage_bytes = register_int_gauge!(\n            Opts::new(\"memory_usage_bytes\", \"Current memory usage in bytes\")\n        )?;\n        let cpu_usage_percent = register_gauge!(\n            Opts::new(\"cpu_usage_percent\", \"Current CPU usage percentage\")\n        )?;\n        let goroutines_count = register_int_gauge!(\n            Opts::new(\"goroutines_count\", \"Current number of goroutines\")\n        )?;\n        \n        // Business metrics\n        let total_volume_traded_usd = register_counter!(\n            Opts::new(\"total_volume_traded_usd\", \"Total trading volume in USD\")\n        )?;\n        let total_rebates_earned_sol = register_counter!(\n            Opts::new(\"total_rebates_earned_sol\", \"Total rebates earned in SOL\")\n        )?;\n        let unique_tokens_traded = register_int_gauge!(\n            Opts::new(\"unique_tokens_traded\", \"Number of unique tokens traded\")\n        )?;\n        \n        let start_time = Instant::now();\n        \n        info!(\"Metrics collector initialized with {} metrics\", 25);\n        \n        Ok(Self {\n            trades_total,\n            trades_successful,\n            trades_failed,\n            trade_volume_sol,\n            trade_duration,\n            jupiter_requests_total,\n            jupiter_requests_failed,\n            jupiter_response_time,\n            helius_requests_total,\n            helius_requests_failed,\n            helius_response_time,\n            solana_rpc_requests_total,\n            solana_rpc_requests_failed,\n            solana_rpc_response_time,\n            cache_hits_total,\n            cache_misses_total,\n            cache_entries,\n            cache_hit_rate,\n            circuit_breaker_state,\n            circuit_breaker_failures,\n            active_users,\n            user_requests_total,\n            user_requests_rate_limited,\n            memory_usage_bytes,\n            cpu_usage_percent,\n            goroutines_count,\n            total_volume_traded_usd,\n            total_rebates_earned_sol,\n            unique_tokens_traded,\n            registry,\n            start_time,\n            last_metrics_export: Arc::new(RwLock::new(Instant::now())),\n        })\n    }\n    \n    // Trading metrics\n    pub fn record_trade_attempt(&self) {\n        self.trades_total.inc();\n    }\n    \n    pub fn record_trade_success(&self, volume_sol: f64, duration: Duration) {\n        self.trades_successful.inc();\n        self.trade_volume_sol.inc_by(volume_sol);\n        self.trade_duration.observe(duration.as_secs_f64());\n    }\n    \n    pub fn record_trade_failure(&self) {\n        self.trades_failed.inc();\n    }\n    \n    // API metrics\n    pub fn record_jupiter_request(&self, duration: Duration, success: bool) {\n        self.jupiter_requests_total.inc();\n        self.jupiter_response_time.observe(duration.as_secs_f64());\n        if !success {\n            self.jupiter_requests_failed.inc();\n        }\n    }\n    \n    pub fn record_helius_request(&self, duration: Duration, success: bool) {\n        self.helius_requests_total.inc();\n        self.helius_response_time.observe(duration.as_secs_f64());\n        if !success {\n            self.helius_requests_failed.inc();\n        }\n    }\n    \n    pub fn record_solana_rpc_request(&self, duration: Duration, success: bool) {\n        self.solana_rpc_requests_total.inc();\n        self.solana_rpc_response_time.observe(duration.as_secs_f64());\n        if !success {\n            self.solana_rpc_requests_failed.inc();\n        }\n    }\n    \n    // Cache metrics\n    pub fn record_cache_hit(&self) {\n        self.cache_hits_total.inc();\n        self.update_cache_hit_rate();\n    }\n    \n    pub fn record_cache_miss(&self) {\n        self.cache_misses_total.inc();\n        self.update_cache_hit_rate();\n    }\n    \n    pub fn update_cache_entries(&self, count: i64) {\n        self.cache_entries.set(count);\n    }\n    \n    fn update_cache_hit_rate(&self) {\n        let hits = self.cache_hits_total.get();\n        let misses = self.cache_misses_total.get();\n        let total = hits + misses;\n        \n        if total > 0 {\n            let hit_rate = (hits as f64 / total as f64) * 100.0;\n            self.cache_hit_rate.set(hit_rate);\n        }\n    }\n    \n    // Circuit breaker metrics\n    pub fn update_circuit_breaker_state(&self, state: u8) {\n        self.circuit_breaker_state.set(state as i64);\n    }\n    \n    pub fn record_circuit_breaker_failure(&self) {\n        self.circuit_breaker_failures.inc();\n    }\n    \n    // User metrics\n    pub fn update_active_users(&self, count: i64) {\n        self.active_users.set(count);\n    }\n    \n    pub fn record_user_request(&self) {\n        self.user_requests_total.inc();\n    }\n    \n    pub fn record_rate_limited_request(&self) {\n        self.user_requests_rate_limited.inc();\n    }\n    \n    // System metrics\n    pub fn update_memory_usage(&self, bytes: i64) {\n        self.memory_usage_bytes.set(bytes);\n    }\n    \n    pub fn update_cpu_usage(&self, percent: f64) {\n        self.cpu_usage_percent.set(percent);\n    }\n    \n    // Business metrics\n    pub fn record_volume_traded(&self, usd_amount: f64) {\n        self.total_volume_traded_usd.inc_by(usd_amount);\n    }\n    \n    pub fn record_rebate_earned(&self, sol_amount: f64) {\n        self.total_rebates_earned_sol.inc_by(sol_amount);\n    }\n    \n    pub fn update_unique_tokens_traded(&self, count: i64) {\n        self.unique_tokens_traded.set(count);\n    }\n    \n    /// Get uptime in seconds\n    pub fn uptime_seconds(&self) -> f64 {\n        self.start_time.elapsed().as_secs_f64()\n    }\n    \n    /// Export metrics in Prometheus format\n    pub fn export_metrics(&self) -> Result<String, Box<dyn std::error::Error>> {\n        let encoder = TextEncoder::new();\n        let metric_families = prometheus::gather();\n        let mut buffer = Vec::new();\n        encoder.encode(&metric_families, &mut buffer)?;\n        Ok(String::from_utf8(buffer)?)\n    }\n    \n    /// Get comprehensive metrics summary\n    pub async fn get_metrics_summary(&self) -> MetricsSummary {\n        let uptime = self.uptime_seconds();\n        let trades_total = self.trades_total.get();\n        let trades_successful = self.trades_successful.get();\n        let trades_failed = self.trades_failed.get();\n        \n        let success_rate = if trades_total > 0 {\n            (trades_successful as f64 / trades_total as f64) * 100.0\n        } else {\n            0.0\n        };\n        \n        let cache_hits = self.cache_hits_total.get();\n        let cache_misses = self.cache_misses_total.get();\n        let cache_total = cache_hits + cache_misses;\n        let cache_hit_rate = if cache_total > 0 {\n            (cache_hits as f64 / cache_total as f64) * 100.0\n        } else {\n            0.0\n        };\n        \n        MetricsSummary {\n            uptime_seconds: uptime,\n            trades_total,\n            success_rate,\n            total_volume_sol: self.trade_volume_sol.get(),\n            total_rebates_sol: self.total_rebates_earned_sol.get(),\n            cache_hit_rate,\n            active_users: self.active_users.get(),\n            memory_usage_mb: self.memory_usage_bytes.get() as f64 / 1024.0 / 1024.0,\n            \n            api_requests: ApiRequestSummary {\n                jupiter_total: self.jupiter_requests_total.get(),\n                jupiter_failed: self.jupiter_requests_failed.get(),\n                helius_total: self.helius_requests_total.get(),\n                helius_failed: self.helius_requests_failed.get(),\n                solana_rpc_total: self.solana_rpc_requests_total.get(),\n                solana_rpc_failed: self.solana_rpc_requests_failed.get(),\n            }\n        }\n    }\n    \n    /// Start background metrics collection\n    pub async fn start_background_collection(&self) {\n        info!(\"Starting background metrics collection\");\n        \n        let metrics = self.clone();\n        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(Duration::from_secs(60));\n            \n            loop {\n                interval.tick().await;\n                \n                // Collect system metrics\n                if let Ok(memory) = get_memory_usage() {\n                    metrics.update_memory_usage(memory as i64);\n                }\n                \n                if let Ok(cpu) = get_cpu_usage().await {\n                    metrics.update_cpu_usage(cpu);\n                }\n                \n                // Log metrics summary every 5 minutes\n                let mut last_export = metrics.last_metrics_export.write().await;\n                if last_export.elapsed() >= Duration::from_secs(300) {\n                    let summary = metrics.get_metrics_summary().await;\n                    info!(\"Metrics Summary: {} trades ({}% success), cache hit rate: {}%, uptime: {}s\", \n                          summary.trades_total, summary.success_rate, summary.cache_hit_rate, summary.uptime_seconds);\n                    *last_export = Instant::now();\n                }\n            }\n        });\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct MetricsSummary {\n    pub uptime_seconds: f64,\n    pub trades_total: u64,\n    pub success_rate: f64,\n    pub total_volume_sol: f64,\n    pub total_rebates_sol: f64,\n    pub cache_hit_rate: f64,\n    pub active_users: i64,\n    pub memory_usage_mb: f64,\n    pub api_requests: ApiRequestSummary,\n}\n\n#[derive(Debug, Clone)]\npub struct ApiRequestSummary {\n    pub jupiter_total: u64,\n    pub jupiter_failed: u64,\n    pub helius_total: u64,\n    pub helius_failed: u64,\n    pub solana_rpc_total: u64,\n    pub solana_rpc_failed: u64,\n}\n\n// System metrics collection (simplified)\nfn get_memory_usage() -> Result<u64, Box<dyn std::error::Error>> {\n    // In a real implementation, this would use system APIs\n    // For now, return a placeholder\n    Ok(1024 * 1024 * 100) // 100MB placeholder\n}\n\nasync fn get_cpu_usage() -> Result<f64, Box<dyn std::error::Error>> {\n    // In a real implementation, this would calculate actual CPU usage\n    // For now, return a placeholder\n    Ok(15.5) // 15.5% placeholder\n}