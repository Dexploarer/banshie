use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::RwLock;
use tracing::{info, warn, error, debug};
use serde::{Serialize, Deserialize};

/// Health checker for monitoring system components
#[derive(Clone)]
pub struct HealthChecker {
    checks: Arc<RwLock<HashMap<String, HealthCheck>>>,
    last_check: Arc<RwLock<Instant>>,
    check_interval: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthCheck {
    pub name: String,
    pub status: HealthStatus,
    pub last_check: String,
    pub response_time_ms: u64,
    pub error_message: Option<String>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Degraded,
    Unhealthy,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemHealth {
    pub overall_status: HealthStatus,
    pub checks: Vec<HealthCheck>,
    pub summary: HealthSummary,
    pub timestamp: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthSummary {
    pub total_checks: usize,
    pub healthy_count: usize,
    pub degraded_count: usize,
    pub unhealthy_count: usize,
    pub unknown_count: usize,
    pub response_time_avg_ms: f64,
}

impl HealthChecker {
    pub fn new(check_interval: Duration) -> Self {
        info!("Initializing health checker with interval: {:?}", check_interval);
        
        Self {
            checks: Arc::new(RwLock::new(HashMap::new())),
            last_check: Arc::new(RwLock::new(Instant::now())),
            check_interval,
        }
    }
    
    /// Start background health monitoring
    pub async fn start_monitoring(&self) {
        info!("Starting background health monitoring");
        
        let checker = self.clone();
        tokio::spawn(async move {\n            let mut interval = tokio::time::interval(checker.check_interval);\n            \n            loop {\n                interval.tick().await;\n                \n                let start_time = Instant::now();\n                \n                // Run all health checks\n                checker.check_database_health().await;\n                checker.check_jupiter_health().await;\n                checker.check_helius_health().await;\n                checker.check_solana_rpc_health().await;\n                checker.check_cache_health().await;\n                checker.check_memory_health().await;\n                \n                let check_duration = start_time.elapsed();\n                debug!(\"Health check cycle completed in {:?}\", check_duration);\n                \n                // Update last check time\n                {\n                    let mut last_check = checker.last_check.write().await;\n                    *last_check = Instant::now();\n                }\n                \n                // Log health summary every 5 minutes\n                if check_duration > Duration::from_secs(300) {\n                    let health = checker.get_system_health().await;\n                    info!(\"System Health: {} checks, Overall: {:?}, Avg response: {:.1}ms\", \n                          health.summary.total_checks,\n                          health.overall_status, \n                          health.summary.response_time_avg_ms);\n                }\n            }\n        });\n    }\n    \n    /// Check database connectivity and performance\n    async fn check_database_health(&self) {\n        let start = Instant::now();\n        let mut status = HealthStatus::Healthy;\n        let mut error_message = None;\n        let mut metadata = HashMap::new();\n        \n        // Simulate database health check\n        // In real implementation, this would test actual database connection\n        tokio::time::sleep(Duration::from_millis(5)).await;\n        \n        let response_time = start.elapsed().as_millis() as u64;\n        \n        if response_time > 1000 {\n            status = HealthStatus::Degraded;\n            error_message = Some(\"Database response time is slow\".to_string());\n        }\n        \n        metadata.insert(\"connection_pool_size\".to_string(), \"10\".to_string());\n        metadata.insert(\"active_connections\".to_string(), \"3\".to_string());\n        \n        let check = HealthCheck {\n            name: \"Database\".to_string(),\n            status,\n            last_check: chrono::Utc::now().to_rfc3339(),\n            response_time_ms: response_time,\n            error_message,\n            metadata,\n        };\n        \n        let mut checks = self.checks.write().await;\n        checks.insert(\"database\".to_string(), check);\n    }\n    \n    /// Check Jupiter API health\n    async fn check_jupiter_health(&self) {\n        let start = Instant::now();\n        let mut status = HealthStatus::Healthy;\n        let mut error_message = None;\n        let mut metadata = HashMap::new();\n        \n        // Simulate Jupiter API health check\n        match self.ping_jupiter_api().await {\n            Ok(response_time_ms) => {\n                if response_time_ms > 2000 {\n                    status = HealthStatus::Degraded;\n                    error_message = Some(\"Jupiter API response time is slow\".to_string());\n                }\n                metadata.insert(\"response_time_ms\".to_string(), response_time_ms.to_string());\n            }\n            Err(e) => {\n                status = HealthStatus::Unhealthy;\n                error_message = Some(format!(\"Jupiter API error: {}\", e));\n            }\n        }\n        \n        let check = HealthCheck {\n            name: \"Jupiter API\".to_string(),\n            status,\n            last_check: chrono::Utc::now().to_rfc3339(),\n            response_time_ms: start.elapsed().as_millis() as u64,\n            error_message,\n            metadata,\n        };\n        \n        let mut checks = self.checks.write().await;\n        checks.insert(\"jupiter\".to_string(), check);\n    }\n    \n    /// Check Helius API health\n    async fn check_helius_health(&self) {\n        let start = Instant::now();\n        let mut status = HealthStatus::Healthy;\n        let mut error_message = None;\n        let mut metadata = HashMap::new();\n        \n        match self.ping_helius_api().await {\n            Ok(response_time_ms) => {\n                if response_time_ms > 3000 {\n                    status = HealthStatus::Degraded;\n                    error_message = Some(\"Helius API response time is slow\".to_string());\n                }\n                metadata.insert(\"response_time_ms\".to_string(), response_time_ms.to_string());\n            }\n            Err(e) => {\n                status = HealthStatus::Unhealthy;\n                error_message = Some(format!(\"Helius API error: {}\", e));\n            }\n        }\n        \n        let check = HealthCheck {\n            name: \"Helius API\".to_string(),\n            status,\n            last_check: chrono::Utc::now().to_rfc3339(),\n            response_time_ms: start.elapsed().as_millis() as u64,\n            error_message,\n            metadata,\n        };\n        \n        let mut checks = self.checks.write().await;\n        checks.insert(\"helius\".to_string(), check);\n    }\n    \n    /// Check Solana RPC health\n    async fn check_solana_rpc_health(&self) {\n        let start = Instant::now();\n        let mut status = HealthStatus::Healthy;\n        let mut error_message = None;\n        let mut metadata = HashMap::new();\n        \n        match self.ping_solana_rpc().await {\n            Ok((response_time_ms, slot)) => {\n                if response_time_ms > 5000 {\n                    status = HealthStatus::Degraded;\n                    error_message = Some(\"Solana RPC response time is slow\".to_string());\n                }\n                metadata.insert(\"response_time_ms\".to_string(), response_time_ms.to_string());\n                metadata.insert(\"current_slot\".to_string(), slot.to_string());\n            }\n            Err(e) => {\n                status = HealthStatus::Unhealthy;\n                error_message = Some(format!(\"Solana RPC error: {}\", e));\n            }\n        }\n        \n        let check = HealthCheck {\n            name: \"Solana RPC\".to_string(),\n            status,\n            last_check: chrono::Utc::now().to_rfc3339(),\n            response_time_ms: start.elapsed().as_millis() as u64,\n            error_message,\n            metadata,\n        };\n        \n        let mut checks = self.checks.write().await;\n        checks.insert(\"solana_rpc\".to_string(), check);\n    }\n    \n    /// Check cache system health\n    async fn check_cache_health(&self) {\n        let start = Instant::now();\n        let mut status = HealthStatus::Healthy;\n        let mut error_message = None;\n        let mut metadata = HashMap::new();\n        \n        // Simulate cache health metrics\n        let cache_hit_rate = 85.5; // Placeholder\n        let cache_entries = 1500;  // Placeholder\n        let memory_usage_mb = 45.2; // Placeholder\n        \n        if cache_hit_rate < 50.0 {\n            status = HealthStatus::Degraded;\n            error_message = Some(format!(\"Low cache hit rate: {:.1}%\", cache_hit_rate));\n        }\n        \n        if memory_usage_mb > 500.0 {\n            status = HealthStatus::Degraded;\n            error_message = Some(format!(\"High cache memory usage: {:.1}MB\", memory_usage_mb));\n        }\n        \n        metadata.insert(\"hit_rate_percent\".to_string(), format!(\"{:.1}\", cache_hit_rate));\n        metadata.insert(\"entries_count\".to_string(), cache_entries.to_string());\n        metadata.insert(\"memory_usage_mb\".to_string(), format!(\"{:.1}\", memory_usage_mb));\n        \n        let check = HealthCheck {\n            name: \"Cache System\".to_string(),\n            status,\n            last_check: chrono::Utc::now().to_rfc3339(),\n            response_time_ms: start.elapsed().as_millis() as u64,\n            error_message,\n            metadata,\n        };\n        \n        let mut checks = self.checks.write().await;\n        checks.insert(\"cache\".to_string(), check);\n    }\n    \n    /// Check system memory health\n    async fn check_memory_health(&self) {\n        let start = Instant::now();\n        let mut status = HealthStatus::Healthy;\n        let mut error_message = None;\n        let mut metadata = HashMap::new();\n        \n        // Simulate memory metrics\n        let memory_usage_mb = 150.5; // Placeholder\n        let memory_limit_mb = 512.0;\n        let memory_usage_percent = (memory_usage_mb / memory_limit_mb) * 100.0;\n        \n        if memory_usage_percent > 80.0 {\n            status = HealthStatus::Unhealthy;\n            error_message = Some(format!(\"High memory usage: {:.1}%\", memory_usage_percent));\n        } else if memory_usage_percent > 60.0 {\n            status = HealthStatus::Degraded;\n            error_message = Some(format!(\"Elevated memory usage: {:.1}%\", memory_usage_percent));\n        }\n        \n        metadata.insert(\"usage_mb\".to_string(), format!(\"{:.1}\", memory_usage_mb));\n        metadata.insert(\"limit_mb\".to_string(), format!(\"{:.1}\", memory_limit_mb));\n        metadata.insert(\"usage_percent\".to_string(), format!(\"{:.1}\", memory_usage_percent));\n        \n        let check = HealthCheck {\n            name: \"System Memory\".to_string(),\n            status,\n            last_check: chrono::Utc::now().to_rfc3339(),\n            response_time_ms: start.elapsed().as_millis() as u64,\n            error_message,\n            metadata,\n        };\n        \n        let mut checks = self.checks.write().await;\n        checks.insert(\"memory\".to_string(), check);\n    }\n    \n    /// Get overall system health\n    pub async fn get_system_health(&self) -> SystemHealth {\n        let checks_map = self.checks.read().await;\n        let checks: Vec<HealthCheck> = checks_map.values().cloned().collect();\n        \n        let mut healthy_count = 0;\n        let mut degraded_count = 0;\n        let mut unhealthy_count = 0;\n        let mut unknown_count = 0;\n        let mut total_response_time = 0u64;\n        \n        for check in &checks {\n            match check.status {\n                HealthStatus::Healthy => healthy_count += 1,\n                HealthStatus::Degraded => degraded_count += 1,\n                HealthStatus::Unhealthy => unhealthy_count += 1,\n                HealthStatus::Unknown => unknown_count += 1,\n            }\n            total_response_time += check.response_time_ms;\n        }\n        \n        let overall_status = if unhealthy_count > 0 {\n            HealthStatus::Unhealthy\n        } else if degraded_count > 0 {\n            HealthStatus::Degraded\n        } else if healthy_count > 0 {\n            HealthStatus::Healthy\n        } else {\n            HealthStatus::Unknown\n        };\n        \n        let response_time_avg_ms = if !checks.is_empty() {\n            total_response_time as f64 / checks.len() as f64\n        } else {\n            0.0\n        };\n        \n        let summary = HealthSummary {\n            total_checks: checks.len(),\n            healthy_count,\n            degraded_count,\n            unhealthy_count,\n            unknown_count,\n            response_time_avg_ms,\n        };\n        \n        SystemHealth {\n            overall_status,\n            checks,\n            summary,\n            timestamp: chrono::Utc::now().to_rfc3339(),\n        }\n    }\n    \n    /// Get health status for a specific component\n    pub async fn get_component_health(&self, component: &str) -> Option<HealthCheck> {\n        let checks = self.checks.read().await;\n        checks.get(component).cloned()\n    }\n    \n    /// Force a health check for all components\n    pub async fn force_health_check(&self) {\n        info!(\"Forcing comprehensive health check\");\n        \n        self.check_database_health().await;\n        self.check_jupiter_health().await;\n        self.check_helius_health().await;\n        self.check_solana_rpc_health().await;\n        self.check_cache_health().await;\n        self.check_memory_health().await;\n        \n        info!(\"Forced health check completed\");\n    }\n    \n    /// Readiness probe - checks if system is ready to serve requests\n    pub async fn readiness_probe(&self) -> bool {\n        let health = self.get_system_health().await;\n        \n        // System is ready if no components are unhealthy\n        health.summary.unhealthy_count == 0\n    }\n    \n    /// Liveness probe - checks if system is alive\n    pub async fn liveness_probe(&self) -> bool {\n        let last_check = self.last_check.read().await;\n        \n        // System is alive if last check was within reasonable time\n        last_check.elapsed() < Duration::from_secs(300) // 5 minutes\n    }\n    \n    // Simulation methods for health checks\n    async fn ping_jupiter_api(&self) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {\n        // Simulate API call\n        tokio::time::sleep(Duration::from_millis(50)).await;\n        Ok(50)\n    }\n    \n    async fn ping_helius_api(&self) -> Result<u64, Box<dyn std::error::Error + Send + Sync>> {\n        // Simulate API call\n        tokio::time::sleep(Duration::from_millis(75)).await;\n        Ok(75)\n    }\n    \n    async fn ping_solana_rpc(&self) -> Result<(u64, u64), Box<dyn std::error::Error + Send + Sync>> {\n        // Simulate RPC call\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        Ok((100, 123456789)) // (response_time_ms, current_slot)\n    }\n}